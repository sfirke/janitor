% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/join_control.R
\name{join_control}
\alias{join_control}
\alias{join_many_to_one}
\alias{join_one_to_many}
\alias{join_one_to_one}
\title{Perform join where the outcome of the join is verifed to match an expected
pattern.}
\usage{
join_control(
  x,
  y,
  join_fun,
  x_control = "any",
  y_control = "any",
  x_fraction = NA_real_,
  y_fraction = NA_real_,
  x_count = NA_integer_,
  y_count = NA_integer_,
  overlap_fraction = NA_real_,
  overlap_count = NA_integer_,
  ...
)

join_many_to_one(x, y)

join_one_to_many(x, y)

join_one_to_one(x, y)
}
\arguments{
\item{x, y}{tbls to join}

\item{join_fun}{Any function that can combine x and y (called as
\code{join_fun(x, y, ...)}).  Typically this will be one of
\code{dplyr::left_join}, \code{dplyr::right_join}, etc.}

\item{x_control, y_control}{What outcome is expected from the \code{x}, and
\code{y} tbls? Default is "any" (see details).}

\item{x_fraction, y_fraction, x_count, y_count}{What fraction or count of the
rows of \code{x} and \code{y} must be in the final data?  Fractions are
converted to row counts by rounding up to the nearest integer.}

\item{overlap_fraction, overlap_count}{What fraction or count of the rows of
the return value must overlap (i.e. have rows from both) \code{x} and
\code{y}?  Fractions are converted to row counts by rounding up to the
nearest integer.}

\item{...}{Passed to \code{join_fun()}}
}
\value{
A joined tbl
}
\description{
Perform join where the outcome of the join is verifed to match an expected
pattern.
}
\details{
Options for \code{x_control} and \code{y_control} are below and may be
  combined:

\itemize{
\item{\code{"any"}: Any outcome is acceptable; this overrides all other options.}
\item{\code{"all"}: Each row from the input must appear in the output at least one
  time.}
\item{\code{"unique"}: A row may appear in the output zero or one time.}
\item{\code{"missing"}: At least one row must not match in the new dataset (the values
  must be missing).  This option is rarely used.}
\item{\code{"nomissing"}: All rows must match in the new dataset (the values must not
  be missing).}
}

The combination of \code{x_control=c("all", "unique", "nomissing")} (or
\code{y_control}) is a common need to confirm that all values are present
exactly one time and that there are no missing values.
}
\section{Functions}{
\itemize{
\item \code{join_many_to_one}: For the common task of many-to-one mapping, the
helper function `join_many_to_one()` works.

\item \code{join_one_to_many}: For the common task of many-to-one mapping, the
helper function `join_one_to_many()` works.

\item \code{join_one_to_one}: For the common task of one-to-one mapping, the
helper function `join_one_to_one()` works.
}}

\examples{
x <- data.frame(A=rep(1:2, 2), B=1:4)
y_nomissing <- data.frame(A=1:2, C=1:2)
y_missing <- data.frame(A=1, C=1)
join_many_to_one(x, y_nomissing)
# The next line would give an error and point to the rows that fail
\dontrun{
join_many_to_one(x, y_missing)
}
x <- data.frame(A=rep(1:2, 2), B=1:4)
y <- data.frame(A=rep(1:2, 2), C=1:4)
z <- data.frame(B=1:4, C=5:8)
join_one_to_one(x, z)
# The next line would give an error and point to the rows that fail
\dontrun{
join_one_to_one(x, y)
}
}
\concept{Join control}
\keyword{Internal}
